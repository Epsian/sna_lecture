---
title: Network Analysis in R
author: "[Jared Joseph](https://jnjoseph.com/)"
date: January 13, 2020
output: rmdformats::readthedown
bibliography: references.bib
link-citations: TRUE
---

```{r setup, include=FALSE}
library(knitr)
library(rmdformats)
library(statnet)
library(visNetwork)

## Global options
options(max.print="75")
opts_chunk$set(echo=TRUE,
	             cache=TRUE,
               prompt=FALSE,
               tidy=TRUE,
               comment=NA,
               message=FALSE,
               warning=FALSE)
opts_knit$set(width=75)
```

```{r links, echo=FALSE}
# emojis
net_url1 = "https://raw.githubusercontent.com/Epsian/sna_lecture/main/resources/male-teacher_emoji.png"
net_url2 = "https://raw.githubusercontent.com/Epsian/sna_lecture/main/resources/female-student_emoji.png"
net_url3 = "https://raw.githubusercontent.com/Epsian/sna_lecture/main/resources/female-health-worker_emoji.png"
net_url4 = "https://raw.githubusercontent.com/Epsian/sna_lecture/main/resources/male-scientist_emoji.png"

# examples
net_url5 = "https://raw.githubusercontent.com/Epsian/sna_lecture/main/resources/who_shall_survive.png"
net_url6 = "https://raw.githubusercontent.com/Epsian/sna_lecture/main/resources/neuronet.jpg"
net_url7 = "https://raw.githubusercontent.com/Epsian/sna_lecture/main/resources/chem_graph.jpg"
net_url8 = "https://raw.githubusercontent.com/Epsian/sna_lecture/main/resources/page_rank.jpg"
net_url9 = "https://raw.githubusercontent.com/Epsian/sna_lecture/main/resources/infrastructure_net.jpg"
net_url10 = "https://raw.githubusercontent.com/Epsian/sna_lecture/main/resources/terror_net.png"
```

# Overview

*write summary here*

## While you wait

-   Make sure you have installed all the packages you will need: `install.packages(c("statnet", "igraph", "intergraph"))`
-   *DOWNLOAD DATA*
-   Play around with <https://oracleofbacon.org/>

## Learning Objectives

By the end of this class meeting, students should be able to:

-   Understand what a network is.
-   Understand what is and is not relational data.
-   Understand the shortcomings and limitations of network analysis.
-   Analyze the utility of a dataset for network analysis.
-   Evaluate a network dataset and interpret the generated metrics.

## Roadmap

-   What is Social Network Analysis (SNA)
-   Examples of networks in research
-   SNA Data
-   Network (graph) level properties
-   Individual (node) level properties
-   SNA Tools
-   Guided Homework Start/Question Time

# What is Network Analysis

You are all most likely familiar now with tabular data; rows and columns containing information. It looks like this:

| Person                               | Name | Age | Widgits |
|--------------------------------------|:-----|:----|:--------|
| ![](`r net_url1`){width="10%"} | J    | 30  | 1       |
| ![](`r net_url2`){width="10%"} | Y    | 21  | 3       |
| ![](`r net_url3`){width="10%"} | G    | 32  | 4       |
| ![](`r net_url4`){width="10%"} | Z    | 48  | 8       |

While this is a tidy way to store data, it artificially atomizes or separates many of the things we are interested in as researchers, social or otherwise. Network analysis is a tool to work with *relational* data. This is the information about how individuals are connected with each other. For example, the diagram below shows the same data as the table above, with the added benefit of showing how these individuals are connected to each other. Hover over the people to reveal the data about them.

```{r echo=FALSE, out.width='100%'}
nodes = data.frame(id = 1:4, 
                    shape = "image",
                    title = c("<p style='color: black;'>Name: J<br>Age: 30<br>Widgits: 1</p>", "<p style='color: black;'>Name: Y<br>Age: 21<br>Widgits: 3</p>", "<p style='color: black;'>Name: G<br>Age: 32<br>Widgits: 4</p>", "<p style='color: black;'>Name: Z<br>Age: 48<br>Widgits: 8</p>"),
                    image = c(net_url1, net_url2, net_url3, net_url4))

edges = data.frame(from = c(2,4,3,3), to = c(1,2,4,2), label = c("Siblings", "Student", "Friends", "Parent"))

visNetwork(nodes, edges, width = "100%") %>% 
  visNodes(shapeProperties = list(useBorderWithImage = FALSE), size = 50) %>%
  visEdges(length = 200, scaling = list(min = 400)) %>%
  visInteraction(zoomView = FALSE) %>%
  visLayout(randomSeed = 2)
```

Rather than looking only at attributes of specific data points, we are looking at the connections between data. In network analysis, data points are called *nodes* or *vertices*, and the connections between them are called *edges* or *ties*. Vertices can be anything---people, places, word, concepts---they are usually mapped into rows in a data frame. Edges contain any information on how these things connect or are related to each other. These components create a *network* or *graph*, defined as "finite set or sets of actors and the relation or relations defined on them" [@wassermanSocialNetworkAnalysis1994].

## Networks in research - Social Sciences

```{r echo=FALSE, out.width= "25%", out.extra='style="float:right; padding:10px"'}
knitr::include_graphics(net_url5)
```

One of the first instances of social network analysis was originally published in 1932 as part of Jacob Moreno's *Who Shall Survive* [-@morenoWhoShallSurvive1953]. This study used the friendship networks of girls within a reform school to show that the ties between them were a stronger predictor of runaways than any attribute of the girls themselves. Since then, networks have been used widely in the social sciences, but only really picked up as the tools to understand SNA became more available.

## Networks in research - Neuroscience

```{r echo=FALSE, out.width= "25%", out.extra='style="float:right; padding:10px"'}
knitr::include_graphics(net_url6)
```

Neuroscientists use networks to study the brain, given their ready application to neurons and pathways. Bassett and Sporns [-@bassettNetworkNeuroscience2017] provide an overview of how to translate neuroscience problems into network ones, and the tools available to study them.

## Networks in research - Chemistry

```{r echo=FALSE, out.width= "25%", out.extra='style="float:right; padding:10px"'}
knitr::include_graphics(net_url7)
```

Chemistry was quick to see the applications of networks. As early at 1985 papers were published detailing the potential networks provided in terms of understanding and finding new ways to measure and understand the bonds between atoms and molecules [@balabanApplicationsGraphTheory1985].

## Networks in research - The Internet

```{r echo=FALSE, out.width= "25%", out.extra='style="float:right; padding:10px"'}
knitr::include_graphics(net_url8)
```

The internet is a network! Beyond the various social network sites, servers themselves act as nodes and the information flows between them along edges. Google used this property in the first version of their search engine, which used the network metric of PageRank to determine which sites to show at the top of search results [@pageMethodNodeRanking2001].

## Networks in research - Infrastructure

```{r echo=FALSE, out.width= "25%", out.extra='style="float:right; padding:10px"'}
knitr::include_graphics(net_url9)
```

Fand and Mostafavi [-@fanGraphbasedMethodSocial2019] showed how you can use social media network data to find where infrastructure is failing during disasters, such as hurricane Harvey in 2017. Their system promises a method to monitor physical infrastructure like roads, bridges, and barriers like more easily monitored infrastructure like the electrical grid.

## Networks in research - Security

```{r echo=FALSE, out.width= "25%", out.extra='style="float:right; padding:10px"'}
knitr::include_graphics(net_url10)
```

Network analysis has also been used for offensive purposes. One of the most prominent uses is mapping crime or terror networks [@krebsMappingNetworksTerrorist2002], though it is fraught with ethical concerns. There are specific tools made for this purpose, such as the *keyplayer* package [@anKeyplayerPackageLocating2016], which helps find what nodes in a network would fragment them the most if removed.

# Network Data

Networks are based on relational data. This means the core data requirement is that we have some measure of how nodes are connected. The two most common network data formats are the *edgelist* and *adjacency matrix*. Either of these will work for nearly any network purpose, and it is easy to convert between them. You will also need an *attributes* file, which gives information about the nodes being connected.

## Edgelist

An edgelist is a two-column dataframe with a *sender* and *receiver* column. Each row represents one edge or tie, with the possibility of adding in more information. Here is an example of a basic edgelist. 

| from              | to                |
|-------------------|-------------------|
| Jesse Faden | Samantha Carter   |
| Levi Ackerman | Samantha Carter   |
| Samantha Carter | Alyx Vance    |
| Ameiko Kaijitsu | Levi Ackerman    |
| Paul Atreides | Alyx Vance    |
| Levi Ackerman | Jesse Faden    |
| Alyx Vance | Ramona Flowers  |
| Jesse Faden | Ameiko Kaijitsu |
| Ramona Flowers | Ameiko Kaijitsu |
| Gordon Freeman | Paul Atreides |
| Alyx Vance | Gordon Freeman  |
| Ramona Flowers | Levi Ackerman |
| Gordon Freeman | Spike Spiegel  |
| Alyx Vance | Spike Spiegel  |
| Jesse Faden | Edward Elric    |

```{r include=FALSE}
# create this network silently for easy matrix conversion
toy_edgelist = data.frame(from = c("Jesse Faden", "Levi Ackerman", "Samantha Carter", "Ameiko Kaijitsu", "Paul Atreides", "Levi Ackerman", "Alyx Vance", "Jesse Faden", "Ramona Flowers", "Gordon Freeman", "Alyx Vance", "Ramona Flowers", "Gordon Freeman", "Alyx Vance", "Jesse Faden"), to = c("Samantha Carter", "Samantha Carter", "Alyx Vance", "Levi Ackerman", "Alyx Vance", "Jesse Faden", "Ramona Flowers", "Ameiko Kaijitsu", "Ameiko Kaijitsu", "Paul Atreides", "Gordon Freeman", "Levi Ackerman", "Spike Spiegel", "Spike Spiegel", "Edward Elric"), stringsAsFactors = FALSE)
```

## Adjacency Matrix

The same data can also be displayed in a table format. The information is the same, but it is presented in a way more usable by our code to create measures we care out. In this format, every node has both a row and column. If there is an edge between two nodes, a 1 is placed in the intersection of their row and column.

```{r echo=FALSE}
knitr::kable(as.matrix(network(toy_edgelist)))
```

## Attributes

Each network also typically has an attributes table, which looks just like typical tabular data, with each row belowing to a specific node in our network. For the examples above, our attribute table might look like the following:

```{r include=FALSE}
toy_attributes = data.frame(
  "id" = 1:10,
  "name" = c("Samantha Carter", "Alyx Vance", "Jesse Faden", "Ramona Flowers", "Ameiko Kaijitsu", "Paul Atreides", "Gordon Freeman", "Levi Ackerman", "Spike Spiegel", "Edward Elric"),
  stringsAsFactors = FALSE)
```

```{r echo=FALSE}
knitr::kable(toy_attributes)
```

## Create an Example Network

Before we start exploring specific measures, let's create a toy network to use as an example. Let's start by loading in some packages.

`statnet` is one of the major network packages in R. It allows you to compute many of the most common network measures, and run simulations called *Exponential Random Graph Models*. We'll stick with the basics for now! 

```{r message=FALSE, warning=FALSE}
# Run this to load statnet, if you need to install it, do so now.
library(statnet)
```

Now that we have our tools loaded, let's create out first network. We'll use the data you saw before. This toy network will be used as a visual for learning the measurements below.

First we make the edgelist ...

```{r message=FALSE, warning=FALSE}
# create the edgelist
toy_edgelist = data.frame(from = c("Jesse Faden", "Levi Ackerman", "Samantha Carter", "Ameiko Kaijitsu", "Paul Atreides", "Levi Ackerman", "Alyx Vance", "Jesse Faden", "Ramona Flowers", "Gordon Freeman", "Alyx Vance", "Ramona Flowers", "Gordon Freeman", "Alyx Vance", "Jesse Faden"), to = c("Samantha Carter", "Samantha Carter", "Alyx Vance", "Levi Ackerman", "Alyx Vance", "Jesse Faden", "Ramona Flowers", "Ameiko Kaijitsu", "Ameiko Kaijitsu", "Paul Atreides", "Gordon Freeman", "Levi Ackerman", "Spike Spiegel", "Spike Spiegel", "Edward Elric"), stringsAsFactors = FALSE)
```

Then the attributes dataframe ...

```{r message=FALSE, warning=FALSE}
# create the attributes dataframe
toy_attributes = data.frame(
  "id" = c("Samantha Carter", "Alyx Vance", "Jesse Faden", "Ramona Flowers", "Ameiko Kaijitsu", "Paul Atreides", "Gordon Freeman", "Levi Ackerman", "Spike Spiegel", "Edward Elric"),
  "age" = c(41, 24, 30, 24, 31, 33, 27, 33, 27, 18),
  stringsAsFactors = FALSE)
```

Finally, we turn it into a `statnet` network object! A `statnet` network object is a special kind of list in R. It is formatted in a way that the other `statnet` functions expect. While you could edit it like a normal list, it is highly recommended you use the other `statnet` functions to manipulate this object to make sure you don't break any of the data expectations.

We'll use the `network` function to create our network object. Before we create it, we will sort our attributes file alphabetically. This is super important, as the network object will automatically sort things itself. **If we do not sort our attributes dataframe to match, all of our measure later will be misaligned!**

```{r}
# sort your attributes frame alphabetically. Super important!
toy_attributes = toy_attributes[order(toy_attributes$id), ]

# make network!
toy_network = network(toy_edgelist, directed = FALSE)
```

Before we move on, let's add a `net_id` column to our attributes dataframe. This will let us easily check what the network object IDs are for our nodes.

```{r}
# add ID column
toy_attributes$net_id = 1:nrow(toy_attributes)
```

We can inspect our new network by calling the `summary` function on it. Don't worry too much about the output yet.

```{r}
summary(toy_network)
```

Then we'll add the node attributes to the network object. If you run `summary` again you should see the values from our `toy_attributes` has been added.

```{r}
# add each attribute to network
# do this by looking at every column, then adding it to the network
for(col_name in colnames(toy_attributes)) {
    toy_network = set.vertex.attribute(x = toy_network, attrname = col_name, value=toy_attributes[,col_name])
}
```

Let's see what out network looks like!

```{r}
plot(toy_network)
```

There we are. The default plotting in `statnet` is ugly. For the sake of our eyes, and for exploring some of the measure we create, we'll use the `visNetwork` package to visualize our networks. It will make the code a bit more cumbersome, but it will be worth it. From now on, we will need to use the edges and attributes dataframes for plotting. This means we will often need to run commands twice, once for the network and once for the dataframes. When you are working with networks for research, you would usually do everything you need on your network, than create a dataframe from it all at once. We will need to deal with a bit of redundancy to take things one step at a time.

Let's try plotting again with `visNetwork`, using the dataframes. We'll give the `visNetwork` function our edgelist and attributes dataframe. We'll also tell it to plot the names from our attributes dataframe so we can see them when we hover over the nodes in the plot.

```{r}
# add pop-up tooltips with names
# visNetwork uses the "title" column to create pop-up boxes
toy_attributes$title = toy_attributes$id

# plot!
visNetwork(nodes = toy_attributes, edges = toy_edgelist) %>% visInteraction(zoomView = FALSE)
```

# Graph Level Properties

Now that we know what networks are and have some examples of how they are used and the data required, let's get into actually analyzing them. There are a number of measures we can compute to understand the structure of a network as a whole. We will go over some basic network level ones here. These are single measures or attributes used to describe the entire network, and can be used to compare one network against another.

* Directed or Un-directed
* Density
* Centralization

## Directed or Un-directed

Networks can either be *directed* or *un-directed*. A directed network treats the edges between nodes as having a specific direction of flow, while an un-directed network considers all edges to be mutual. An example of each is presented below.

Both edgelist and adjacency matrix datasets are inherently directed. For edgelists, the sender is often the first column, and the receiver is the second. For adjacency matrices the rows are considered senders and columns are receivers. Directionality is often specified when the network objects are created. When we created our toy network, we specified `directed = FALSE` to simplify things. If you want a directed network, the default is `directed = TRUE` for `statnet` networks.

A directed network tracks which node is the source and which node is the receiver for an edge. Take for example the *follow* mechanic on Twitter. User A can follow User B, creating a directed edge from A to B, but B does not have to follow A in return. This can be useful when trying to understand the flows of resources that are finite such as money or goods.

```{r Directionality, echo=FALSE}
# visNetwork uses a column called "arrows" to show directionality in its plots.
# For our edgelist, we'll just say every row is "to" for now
toy_edgelist$arrows = "to"

# this will show us what our network would look like if it was directed.
visNetwork(toy_attributes, toy_edgelist, main = "Directed") %>% visInteraction(zoomView = FALSE)
```

An un-directed network treats all ties as mutual, such that A and B are both involved equally in a tie. An example is the *friend* mechanic on Facebook. Once a friendship is established, both users are considered equal in the tie. This can be helpful when you do not have information on what node initiates a tie, or when events happen equally to a group of nodes, such as all nodes being connected through co-membership in a group.

```{r echo=FALSE}
# lets drop the arrow column for now since our network is un-directed.
toy_edgelist = toy_edgelist[,c("from", "to")]

visNetwork(toy_attributes, toy_edgelist, main = "Un-directed") %>% visInteraction(zoomView = FALSE)
```

Which of these will be useful to you will likely change from project to project. However, it is vital to understand what kind of network you are working with, as many network calculations we will talk about later change their behavior based on if the network is directed or not.

## Density

*Density* is the first real graph level metric that helps you understand what is particular about the network you are looking at. The density of a network is a numerical score showing how many ties exist in a network, given the max possible in that network. Mathematically that is $\frac{Actual Edges}{Possible Edges}$, where actual edges is the number of edges in the network, and possible edges is the number of edges if every single node in the network was connected to every other node.

Networks that are more densely connected are considered to be more cohesive and robust. This means that the removal of any specific edge or node will not have a great effect of the network as a whole. It also typically means that any one node in the network will be more likely to have access to whatever resources are in the network, as there are more potential connections in the network to search for resources.

To calculate the density of a network, we use the `network.density()` function. You can also see it if you use `summary()` on your network object. Below is our toy network and a less dense version to try and visualize the difference. Density is all about how many edges exist in the network. Notice that there are the same number of nodes in both of these networks.

```{r echo=FALSE}
visNetwork(toy_attributes, toy_edgelist, main = "High Density") %>% visInteraction(zoomView = FALSE)
```

```{r echo=FALSE}
visNetwork(toy_attributes, toy_edgelist[c(1:5,7,10,13,15),1:2], main = "Low Density") %>% visInteraction(zoomView = FALSE)
```

## Centralization

*Freeman Centralization* (usually just called *centralization*) gives a sense of the shape of the network, namely how node level measures are distributed in a network. We'll discuss node level measures next, but for now it is only important to understand that node level measures are numeric scores assigned to specific nodes rather than the network as a whole. This means that each node may have a different value.

Consider the two networks below. The first "star" network would be considered highly centralized, as one node connects to all the others, while the rest of the nodes have no connections to each other. This star network would have a edge centralization score of 1, as 100% of the ties are connected with one node. The loop network would have a score of 0, as every node is equally connected to each other.

Centralization is a measure of how unevenly node level metrics are distributed in a network. This is helpful when trying to understand if some nodes in the network have a larger influence, or are is some way more important than others. 

```{r echo=FALSE}
# create a dummy network to show the star shape
.star_edge = data.frame("from" = c(1,2,3,4,5), "to" = c(6,6,6,6,6))

visNetwork(data.frame("id" = 1:6), .star_edge, main = "Star Network") %>% visInteraction(zoomView = FALSE)
```

```{r echo=FALSE}
# create a dummy network to show the loop shape
.loop_edge = data.frame("from" = c(1,2,3,4,5,6), "to" = c(2,3,4,5,6,1))

visNetwork(data.frame("id" = 1:6), .loop_edge, main = "Loop Network") %>% visInteraction(zoomView = FALSE) %>% visLayout(randomSeed = 2)
```

# Node Level Properties

Node level measures are numeric representations of a node's position and importance in a network. There are several common node level measures, and we will go over some of them here. Each measure tries to quantify a different aspect of a node's position in the network so we can make an argument about why that specific node or class of nodes is important in some way. We will go over:

* Degree
* Geodesic distance
* Betweenness centrality
* Eigenvector centrality
* k-core
* 

Most node level measures are only helpful within the context of the network they were generated for. This is because the measures are created in part using network level measures like density. This means it is alright to compare one node to another within the same network, but toy should node compare the node level measures between networks.

## Degree

*Degree* counts how many edges are connected to a node. You can count incoming, outgoing, or total (Freeman) degree. Incoming and outgoing degree only matter in directed networks. In un-directed networks, only total edges are applicable. Degree gives a very rough measure of how popular or central a node is in the network. If a node has more ties, it may indicate that node as being more central or important the network as a whole.

Degree is a raw count of the number of edges a node has, this makes the interpretation of degree highly dependent on the size of the network. In a small network with only 25 total edges, having 10 of them would be significant. In a larger network with 250 total edges, 10 edges could be less impressive. Degree should thus be interpreted in the cortex of other nodes in the network. 

Let's scale the node sizes of our toy network based on their total degree numbers. We'll get degree counts for each of our nodes using the `degree()` function. We can save that into our dataframe and network for use later. For now I am naming columns to work specifically with `visNetwork`, we'll make a proper dataframe for analyses later using data we saved in the network object. In our visualization, you can click on any node to highlight only the edges connected to that node.

```{r echo=FALSE}
# find the degree of each node and save in the network
# we will use the special `%v%` operator when assigning values to a network. `%v%` works like `$` for dataframes, allowing you to ask for specific values in the network
# in this case `%v%` stands for vertex, and you can use `%e%` if you want to work with edges.
# so let's get the degree counts, andassign them to the "degree" variable in our network object
toy_network%v%"degree" = degree(toy_network)

# visNetwork uses the "value" column to determine node size, so let's put it there as well for now.
# we'll square the values just to make them more distinct
toy_attributes$value = degree(toy_network)^2

# plot!
visNetwork(toy_attributes, toy_edgelist, main = "Degree Example") %>% visInteraction(zoomView = FALSE)
```

## Geodesic Distance

**Geodesic Distance** is "the length of the shortest path via the edges or binary connections between nodes" [@kadushinUnderstandingSocialNetworks2012]. In other words, if we treat the network as a map we can move along, with the nodes being stopping places and the edges being paths, the geodesic is the shortest possible path between two nodes, and that distance is how many edges we have to walk along for that shortest path. 

Nodes that have a shorter average geodesic distance between all the other nodes in the network are considered to have have greater access to the resources in a network. This is because a node with a low average geodesic distance can theoretically "reach" the other nodes with less effort, because it does not need to travel as far in the network.

To find the mean geodesic distance for each node in the network we will first need to find the geodesic distance from each node to every other node, then take the mean. Not super difficult, but there isn't a single function to do it for us. First we will use the `geodist()` function to get all the geodesics.

```{r}
# get all the geodesics
# I use the $gdist so we only get geodesics not counts
geodist(toy_network)$gdist
```
This output is just like an adjacency matrix, with row and columns being the network node IDs (`net_id` in out attributes dataframe). Next we would want sum all the columns for each row (so adding up all the geodesics for a node), and divide by the total number of nodes it can have an edge with to get the average geodesic distance for that node. This gives us the average geodesic distance for each node!

```{r}
# colsums gives us the sum of all columns for a row
# we subtract one from the denominator becasue a node cannot have a geodesic distance with itself
colSums(geodist(toy_network)$gdist) / (nrow(as.sociomatrix(toy_network)) - 1)
```

Lets add thus to our network and plot it. I will also add some color and labels so it is easier to see what this measure means. The red node has the longest average geodesic distance, and would need to travel through the whole network to reach the nodes on the opposite side. Meanwhile, the blue node has the smallest average geodesic distance because it is located near the middle of the network.

```{r Geodesic, echo=TRUE, message=FALSE, warning=FALSE}
# add mean geodesic distance to network object
toy_network%v%"mean.distance" = 
  (colSums(geodist(toy_network)$gdist))/(nrow(as.sociomatrix(toy_network)) - 1)

# set all node colors in visNetwork to grey as default
toy_attributes$color = c("grey")

# add label as geodesic distance, rounding to 3 digits
toy_attributes$label = round(toy_network%v%"mean.distance", 3)

# replace min average geodesic with blue, max with red
toy_attributes$color[which(toy_network%v%"mean.distance" == max(toy_network%v%"mean.distance"))] = "red"
toy_attributes$color[which(toy_network%v%"mean.distance" == min(toy_network%v%"mean.distance"))] = "blue"

# make sure edges are grey too
toy_edgelist$color = "grey"

# plot
visNetwork(toy_attributes, toy_edgelist, main = "Geodesic Example") %>% visInteraction(zoomView = FALSE)
```
Note that while there is a correlation between degree counts (node size) and mean geodesic distance, one does not cause the other. This is our first instance of how network structure, not node attributes, can inform us about the nodes in a network. Essentially, looking at the network as a whole can tell us things about the people in it that is lost if we look only at individuals.

## Centrality

Centrality scores encompass a wide range of measures computed at the node level. Each tries to understand the importance of a single node within the structure of a network by looking at the nodes connection patterns to other nodes. Any centrality measure can be used to create a network level centralization score like we discussed above. We will go through some of the common centrality measures here, but know there are several more we will not cover.

### Betweenness Centrality

**Betweenness Centrality** is one of the most common centrality measures. It tries to calculate the extent to which a node acts as a gatekeeper or *broker* in the network. A broker bridges two otherwise disconnected segments in a network. If there are two parts of a network that would otherwise be broken apart if a node was removed, they would have a high betweenness centrality. The fragmenting of a network is not a prerequisite however, simply acting as an effective "shortcut" in a network can also raise a node's betweenness centrality. Betweenness is calculated using geodesic distances, and gives a higher score to nodes that lie on more geodesic paths.

The next network plot shows the size of nodes as their degree, with a label showing their betweenness centrality score. Centrality score are usually normalized such that their scores all sum to 1. This way, you can easily compare nodes within the network (but not between networks), and understand how nodes relate to each other structurally. It is possible for a node to have a 0 betweenness score if no geodesic distances pass through them.

Like last time I've colored the nodes so that the node with the highest betweenness centrality is red, while the lowest is blue. Compared to distance however, it is considered advantageous to have a *high* betweenness centrality, as this means that nodes acts as a gatekeeper in the network, which can be a powerful position. Contrast this with having a *low* mean distance, which meant you were closer to all other nodes.

```{r betweenness, echo=TRUE, message=FALSE, warning=FALSE}
# add eigenvector centrality to network object as "norm_betweenness"
# we also tell it we are treating our data as un-directed ("graph"), rather than the default directed ("digraph")
# we also say we want a normalized (0-1, sum to 1) score using `rescale = TRUE`
toy_network%v%"norm_betweenness" = betweenness(dat = toy_network, gmode = "graph", rescale = TRUE)

# add label as geodesic distance, rounding to 3 digits
toy_attributes$label = round(toy_network%v%"norm_betweenness", 3)

# reset all nodes to grey
toy_attributes$color = c("grey")

# replace min average geodesic with blue, max with red
toy_attributes$color[which(toy_network%v%"norm_betweenness" == max(toy_network%v%"norm_betweenness"))] = "red"
toy_attributes$color[which(toy_network%v%"norm_betweenness" == min(toy_network%v%"norm_betweenness"))] = "blue"

# plot
visNetwork(toy_attributes, toy_edgelist, main = "Betweenness Centrality Example") %>% visInteraction(zoomView = FALSE)
```

### Eigenvector Centrality

**Eigenvector Centrality** is commonly known as a measure of "popular friends." Rather than looking at the network position of a node, it looks at the network positions of nodes connected to it. Nodes with a high eigenvector score will be connected to nodes more prominent in the network. Nodes with low degree can have high eigenvector scores if they are connected to important nodes.






 Like last time I've colored the nodes so that the node with the highest eigenvector centrality is red, while the lowest is blue. It is considered advantageous to have a *high* eigenvector centrality, as this means you are well connected to other popular nodes.

```{r eigenvector, echo=TRUE, message=FALSE, warning=FALSE}
# add eigenvector centrality to network object as "evc"
# we also tell it we are treating our data as un-directed ("graph"), rather than the default directed ("digraph")
# we also say we want a normalized (0-1, sum to 1) score using `rescale = TRUE`
toy_network%v%"evc" = evcent(toy_network, gmode = "graph", rescale = TRUE)

# add label as geodesic distance, rounding to 3 digits
toy_attributes$label = round(toy_network%v%"evc", 3)

# reset all nodes to grey
toy_attributes$color = c("grey")

# replace min average geodesic with blue, max with red
toy_attributes$color[which(toy_network%v%"evc" == max(toy_network%v%"evc"))] = "red"
toy_attributes$color[which(toy_network%v%"evc" == min(toy_network%v%"evc"))] = "blue"

# plot
visNetwork(toy_attributes, toy_edgelist, main = "Eigenvector Centrality Example") %>% visInteraction(zoomView = FALSE)
```






## Centrality

**Centrality** measures how prominent a specific node is in a network. **Betweenness Centrality** measures the extent to which a specific node acts as a **broker**, or a person that bridges a gap between two groups. In the Florentine Marriage network, we can see that the Medici act as brokers between three otherwise disconnected segments in the network, giving them a monopoly on how resources flow between these desperate parts of the network. 
```{r Brokers}
#b.col = rep("red", times = 16)
#b.col[1] = "blue"
#b.col[c(10, 14)] = "yellow"
#b.col[9] = "purple"
#b.col[12] = "black"
#plot(flomarriage, main = "Florentine Marriage Network", displaylabels = TRUE, label.pos = 0, vertex.col = b.col, arrowhead.cex = 3, vertex.cex = 3)
```

```{r Betweenness, echo=TRUE}
#bt.o = betweenness(dat = flomarriage, gmode = "graph") #Gets the betweennes centrality measure for each node, with higher values indicating that more connections must flow #through this node.
#names(bt.o) = flomarriage%v%"vertex.names"
#bt.o
```

Another form of centrality is **Eigenvector Centrality**, which is often called a measure of 'popular friends.' Rather than looking at the network position of a node, it looks at the network positions of nodes connected to it. Nodes with a high eigenvector score will be connected to nodes more prominent in the network. A good example case is comparing the Acciaiuoli family, with the Lamberteschi family. Both are only connected with one other family, but one is connected to the Medici.   
```{r Eigenvector}
#ev = evcent(flomarriage, gmode = "graph") # evcent() get te eigenvector centrality for each node in the network and returns a vector. Higher values means having more #'popular friends' 
#names(ev) = flomarriage%v%"vertex.names"
#ev
```

## K-Core

**K-Core** measures the the minimum degree of nodes connected nodes in an area of the network. This results in rudimentary clustering of nodes by the lowest common degree.

```{r, warning=FALSE}
#par(par.d)
#kc = kcores(flomarriage, mode="graph",diag=FALSE) # kcores() generdates a k-core number for each node in the network, and is best understood though visualization
#plot(flomarriage, main = "K-Cores", vertex.cex = 3, vertex.col = kc+1)
```









------------------------------------------------------------------------

# ADD SOMETHING ABOUT WEIGHTED EDGES

# References
